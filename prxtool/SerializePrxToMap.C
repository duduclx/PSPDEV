/***************************************************************
 * PRXTool : Utility for PSP executables.
 * (c) TyRaNiD 2k5
 *
 * SerializePrxToMap.C - Implementation of a class to serialize
 * a loaded PRX file to a PS2DIS Map file.
 ***************************************************************/

#include <stdio.h>
#include "SerializePrxToMap.h"

/* Build a name from a base and extention */
static const char *BuildName(const char* base, const char *ext)
{
	static char str_export[512];

	snprintf(str_export, sizeof(str_export), "%s_%s", base, ext);

	return str_export;
}

static void PrintOffset(FILE *fp, unsigned int addr)
{
	fprintf(fp, "%08x:\n", addr);
}

static void PrintComment(FILE *fp, const char *text)
{
	fprintf(fp, "# %s\n", text);
}

CSerializePrxToMap::CSerializePrxToMap(FILE *fpOut)
{
	m_fpOut = fpOut;
}

CSerializePrxToMap::~CSerializePrxToMap()
{
	fflush(m_fpOut);
}

bool CSerializePrxToMap::StartFile()
{
	return true;
}

bool CSerializePrxToMap::EndFile()
{
	/* Do nothing */
	return true;
}

bool CSerializePrxToMap::StartPrx(const char* szFilename, const PspModule *mod, u32 iSMask)
{
	u32 i;
	u32 addr;

	PrintComment(m_fpOut, "Generated by prxtool");
	PrintComment(m_fpOut, "Make sure to \"Load From Address 0xA0\" to skip the ELF header");
	PrintComment(m_fpOut, "Make sure to load the module as plain binary, not as ELF");
	fprintf(m_fpOut, "# File: %s\n", szFilename);

	addr = mod->addr;

	PrintOffset(m_fpOut, addr);
	fprintf(m_fpOut, ".word\t_module_flags\n");
	fprintf(m_fpOut, ".byte\t_module_name\n");
	for(i=0; i < (sizeof(mod->name)-2); i++)
		fprintf(m_fpOut, ".byte\n");	
	fprintf(m_fpOut, ".word\t_module_gp\n");
	fprintf(m_fpOut, ".word\t_module_exports\n");
	fprintf(m_fpOut, ".word\t_module_exp_end\n");
	fprintf(m_fpOut, ".word\t_module_imports\n");
	fprintf(m_fpOut, ".word\t_module_imp_end\n");

	return true;
}

bool CSerializePrxToMap::EndPrx()
{
	/* Do nothing */
	return true;
}

bool CSerializePrxToMap::StartSects()
{
	/* Do nothing */
	return true;
}

bool CSerializePrxToMap::SerializeSect(int num, ElfSection &sect)
{
	u32 shFlags;
	u32 shType;
	u32 shAddr;
	u32 shSize;
	const char *pName;

	shFlags = sect.iFlags;
	shType = sect.iType;
	shAddr = sect.iAddr;
	shSize = sect.iSize;
	pName = sect.szName;

	/* Check if the section is loadable */
	if((shFlags & SHF_ALLOC) && ((shType == SHT_PROGBITS) || (shType == SHT_NOBITS)))
	{
		PrintOffset(m_fpOut, shAddr);
		fprintf(m_fpOut, ".word\t%s\t;", pName);

		if(shFlags & SHF_EXECINSTR)
		{
			fprintf(m_fpOut, " SEG_CODE");
		}
		else
		{
			if(shType == SHT_NOBITS)
			{
				fprintf(m_fpOut, " SEG_BSS");
			}
			else
			{
				fprintf(m_fpOut, " SEG_DATA");
			}
		}
		
		fprintf(m_fpOut, " 0x%08x - 0x%08x\n", shAddr, shAddr + shSize);
	}

	return true;
}

bool CSerializePrxToMap::EndSects()
{
	return true;
}

bool CSerializePrxToMap::StartImports()
{
	return true;
}

bool CSerializePrxToMap::SerializeImport(int num, const PspLibImport *imp)
{
	char str_import[128];
	int iLoop;
	u32 addr;
	snprintf(str_import, sizeof(str_import), "import%d", num);

	addr = imp->addr;

	if(imp->stub.name != 0)
	{
		PrintOffset(m_fpOut, addr);
		fprintf(m_fpOut, ".word\t%s\t; %s\n", imp->name, BuildName(str_import, "name"));
	}
	else
	{
		PrintOffset(m_fpOut, addr);
		fprintf(m_fpOut, ".word\t%s\t; %s\n", str_import, BuildName(str_import, "name"));
	}

	fprintf(m_fpOut, ".word\t%s\n", BuildName(str_import, "flags"));
	fprintf(m_fpOut, ".word\t%s\n", BuildName(str_import, "counts"));
	fprintf(m_fpOut, ".word\t%s\n", BuildName(str_import, "nids"));
	fprintf(m_fpOut, ".word\t%s\n", BuildName(str_import, "funcs"));

	for(iLoop = 0; iLoop < imp->f_count; iLoop++)
	{
		PrintOffset(m_fpOut, imp->funcs[iLoop].nid_addr);
		fprintf(m_fpOut, ".word\t%s\t; NID %08x\n", BuildName(str_import, imp->funcs[iLoop].name), imp->funcs[iLoop].nid);

		PrintOffset(m_fpOut, imp->funcs[iLoop].addr);
		fprintf(m_fpOut, ".code\t%s\n", imp->funcs[iLoop].name);
	}

	for(iLoop = 0; iLoop < imp->v_count; iLoop++)
	{

		PrintOffset(m_fpOut, imp->funcs[iLoop].nid_addr);
		fprintf(m_fpOut, ".word\t%s\t; NID %08x\n", BuildName(str_import, imp->vars[iLoop].name), imp->vars[iLoop].nid);

		PrintOffset(m_fpOut, imp->vars[iLoop].nid_addr + ((imp->v_count + imp->f_count) * 4));
		fprintf(m_fpOut, ".word\t%s\n", imp->vars[iLoop].name);
	}

	return true;
}

bool CSerializePrxToMap::EndImports()
{
	return true;
}

bool CSerializePrxToMap::StartExports()
{
	return true;
}

bool CSerializePrxToMap::SerializeExport(int num, const PspLibExport *exp)
{
	char str_export[128];
	int iLoop;
	u32 addr;
	snprintf(str_export, sizeof(str_export), "export_%d", num);

	addr = exp->addr;

	if(exp->stub.name != 0)
	{
		PrintOffset(m_fpOut, addr);
		fprintf(m_fpOut, ".word\t%s\t; %s\n", exp->name, BuildName(str_export, "name"));
	}
	else
	{
		PrintOffset(m_fpOut, addr);
		fprintf(m_fpOut, ".word\t%s\t; %s\n", str_export, BuildName(str_export, "name"));
	}
	
	fprintf(m_fpOut, ".word\t%s\n", BuildName(str_export, "flags"));
	fprintf(m_fpOut, ".word\t%s\n", BuildName(str_export, "counts"));
	fprintf(m_fpOut, ".word\t%s\n", BuildName(str_export, "exports"));
	
	for(iLoop = 0; iLoop < exp->f_count; iLoop++)
	{
		PrintOffset(m_fpOut, exp->funcs[iLoop].nid_addr);
		fprintf(m_fpOut, ".word\t%s\t; NID %08x\n", BuildName(str_export, exp->funcs[iLoop].name), exp->funcs[iLoop].nid);

		PrintOffset(m_fpOut, exp->funcs[iLoop].nid_addr + ((exp->v_count + exp->f_count) * 4));
		fprintf(m_fpOut, ".word\n");
		
		PrintOffset(m_fpOut, exp->funcs[iLoop].addr);		
		fprintf(m_fpOut, ".code\t%s\n", exp->funcs[iLoop].name);
	}

	for(iLoop = 0; iLoop < exp->v_count; iLoop++)
	{
		PrintOffset(m_fpOut, exp->funcs[iLoop].nid_addr);
		fprintf(m_fpOut, ".word\t%s\t; NID %08x\n", BuildName(str_export, exp->vars[iLoop].name), exp->vars[iLoop].nid);

		PrintOffset(m_fpOut, exp->vars[iLoop].nid_addr + ((exp->v_count + exp->f_count) * 4));
		fprintf(m_fpOut, ".word\t%s\n", exp->vars[iLoop].name);
	}

	return true;
}

bool CSerializePrxToMap::EndExports()
{
	return true;
}

bool CSerializePrxToMap::StartRelocs()
{
	return true;
}

bool CSerializePrxToMap::SerializeReloc(int count, const ElfReloc *rel)
{
	ElfSection *pDataSect, *pTextSect;

	pDataSect = m_currPrx->ElfFindSection(".data");
	pTextSect = m_currPrx->ElfFindSection(".text");

	fprintf(stderr, "Reloc count %d, %s, data %p, text %p\n", count, rel->secname, pDataSect, pTextSect);
	return true;
}

bool CSerializePrxToMap::EndRelocs()
{
	return true;
}

