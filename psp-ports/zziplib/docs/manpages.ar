!<arch>
//                                              1274      `
zzip_compr_str.3/
zzip_createdir.3/
zzip_dir_alloc.3/
zzip_dir_alloc_ext_io.3/
zzip_dir_close.3/
zzip_dir_creat.3/
zzip_dir_creat_ext_io.3/
zzip_dir_fdopen.3/
zzip_dir_fdopen_ext_io.3/
zzip_dirhandle.3/
zzip_dir_open_ext_io.3/
zzip_disk_close.3/
zzip_disk_entry_fopen.3/
zzip_disk_entry_strdup_name.3/
zzip_disk_entry_to_data.3/
zzip_disk_entry_to_file_header.3/
zzip_disk_fclose.3/
zzip_disk_feof.3/
zzip_disk_findfile.3/
zzip_disk_findfirst.3/
zzip_disk_findmatch.3/
zzip_disk_findnext.3/
zzip_disk_fopen.3/
zzip_disk_fread.3/
zzip_disk_init.3/
zzip_disk_mmap.3/
zzip_disk_munmap.3/
zzip_disk_open.3/
zzip_entry_data_offset.3/
zzip_entry_fclose.3/
zzip_entry_feof.3/
zzip_entry_ffile.3/
zzip_entry_findfile.3/
zzip_entry_findfirst.3/
zzip_entry_findmatch.3/
zzip_entry_findnext.3/
zzip_entry_fopen.3/
zzip_entry_fread.3/
zzip_entry_fread_file_header.3/
zzip_entry_free.3/
zzip_entry_strdup_name.3/
zzip_file_close.3/
zzip_file_creat.3/
zzip_file_mkdir.3/
zzip_file_open.3/
zzip_file_read.3/
zzip_file_real.3/
zzip_file_stat.3/
zzip_file_write.3/
__zzip_find_disk_trailer.3/
zzip_get_default_io.3/
zzip_inflate_init.3/
zzip_opendir_ext_io.3/
zzip_open_ext_io.3/
zzip_open_shared_io.3/
__zzip_parse_root_directory.3/
zzip_rewinddir.3/
zzip_strerror_of.3/
__zzip_try_open.3/
zzip_close.3/   1104300067  1001  0     100664  23        `
.so man3/zzip_fclose.3

zzip_closedir.3/1104300067  1001  0     100664  964       `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_CLOSEDIR" 3 "0.13.38" "zziplib" "zzip_closedir"
.SH NAME
zzip_closedir \- (zzip/dir.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 19
int\ \fBzzip_closedir\fR\ (ZZIP_DIR*\ dir);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_closedir function\fR is the equivalent of \fBclosedir\fR(3) for a realdir or zipfile\&.

.PP
 \fBThe zzip_closedir function\fR is magic \- if the given arg\-ZZIP_DIR is a real directory, it will call the real \fBclosedir\fR(3) and then free the wrapping ZZIP_DIR structure\&. Otherwise it will divert to \fBzzip_dir_close\fR which will free the ZZIP_DIR structure\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

/0              1104300067  1001  0     100664  691       `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_COMPR_STR" 3 "0.13.38" "zziplib" "zzip_compr_str"
.SH NAME
zzip_compr_str \- (zzip/info.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 29
zzip_char_t*\ \fBzzip_compr_str\fR\ (int\ compr);
.ad
.hy

.SH "DESCRIPTION"

.PP
return static const string of the known compression methods, otherwise just "zipped" is returned

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP


zzip_creat.3/   1104300067  1001  0     100664  22        `
.so man3/zzip_mkdir.3
/18             1104300067  1001  0     100664  2352      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_CREATEDIR" 3 "0.13.38" "zziplib" "zzip_createdir"
.SH NAME
zzip_createdir \- create a new archive area for writing
.SH "SYNOPSIS"
.ad l
.hy 0


 #include <zziplib\&.h>

.sp
.HP 26
ZZIP_DIR*\ \fBzzip_createdir\fR\ (zzip_char_t*\ name, int\ o_mode);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_createdir function\fR will create a new archive area\&. This may either be a a new zip archive or a new directory in the filesystem\&. The returned parameter is a new "zzip dir" handle that should be saved to a variable so it can be used a base argument for \fBzzip_file_mkdir\fR and \fBzzip_file_creat\fR calls\&. The returned handle wraps both possibilities, it can be representing a zip central directory that must be saved to disk using \fBzzip_closedir\fR or it is just a handle for the name of the real directory that still must be run through \fBzzip_closedir\fR to release the wrapper around the directory name\&.

.PP
The magic is pushed through the o_mode argument\&. Using a mode that has no group\-write bit set (S_IWGRP = 0040) then the file is created as a zip directory\&. Note that this is unabridged of any umask value in the system where the argument to \fBthe zzip_createdir function\fR could be 0775 but with an umask of 0755 it turns out as 0755 for a real directory\&. Using 0755 directly would not create it as a real directory but as a zip archive handle\&.

.PP
 \fBThe zzip_createdir function\fR is not yet implemented, check for #def ZZIP_NO_CREAT Write\-support will extend \fBzzip_closedir\fR with semantics to finalize the zip\-archive by writing the zip\-trailer and closing the archive file\&.

.PP
Returns null on error and sets errno\&. Remember, according to posix the \fBcreat\fR(2) call is equivalent to 

.IP
  open (path, O_WRONLY | O_CREAT | O_TRUNC, o_mode) so any previous zip\-archive will be overwritten unconditionally and EEXIST errors from \fBmkdir\fR(2) are suppressed\&. (fixme: delete the given subtree? like suggested by O_TRUNC? not done so far!)

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

/36             1104300067  1001  0     100664  33        `
.so man3/zzip_dir_alloc_ext_io.3

/54             1104300067  1001  0     100664  1416      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DIR_ALLOC_EXT" 3 "0.13.38" "zziplib" "zzip_dir_alloc_ext_io"
.SH NAME
zzip_dir_alloc_ext_io, zzip_dir_alloc \- (zzip/zip.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 33
ZZIP_DIR*\ \fBzzip_dir_alloc_ext_io\fR\ (zzip_strings_t*\ ext, const\ zzip_plugin_io_t\ io);
.HP 26
ZZIP_DIR*\ \fBzzip_dir_alloc\fR\ (zzip_strings_t*\ fileext);
.ad
.hy

.SH "DESCRIPTION"

.PP
allocate a new ZZIP_DIR handle and do basic initializations before usage by \fBzzip_dir_fdopen\fR  \fBzzip_dir_open\fR  \fBzzip_file_open\fR or through \fBzzip_open\fR (ext==null flags uses { "\&.zip" , "\&.ZIP" } ) (io ==null flags use of posix io defaults)

.PP
 \fBthe zzip_dir_alloc function\fR is obsolete \- it was generally used for implementation and exported to let other code build on it\&. It is now advised to use \fBzzip_dir_alloc_ext_io\fR now on explicitly, just set that second argument to zero to achieve the same functionality as the old style\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.LP

/79             1104300067  1001  0     100664  25        `
.so man3/zzip_dir_free.3

/97             1104300067  1001  0     100664  2264      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DIR_CREAT" 3 "0.13.38" "zziplib" "zzip_dir_creat"
.SH NAME
zzip_dir_creat, zzip_dir_creat_ext_io \- create a new zip archive for writing
.SH "SYNOPSIS"
.ad l
.hy 0


 #include <zziplib\&.h>

.sp
.HP 26
ZZIP_DIR*\ \fBzzip_dir_creat\fR\ (zzip_char_t*\ name, int\ o_mode);
.HP 33
ZZIP_DIR*\ \fBzzip_dir_creat_ext_io\fR\ (zzip_char_t*\ name, int\ o_mode, zzip_strings_t*\ ext, zzip_plugin_io_t\ io);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_dir_creat function\fR will create a new zip archive\&. The returned parameter is a new "zzip dir" handle that should be saved to a variable so it can be used a base argument for \fBzzip_mkdir\fR and \fBzzip_creat\fR calls\&. The returned handle represents a zip central directory that must be saved to disk using \fBzzip_closedir\fR\&.

.PP
Returns null on error and sets errno\&. Remember, according to posix the \fBcreat\fR(2) call is equivalent to 

.IP
  open (path, O_WRONLY | O_CREAT | O_TRUNC, o_mode) so any previous zip\-archive will be overwritten unconditionally and EEXIST errors from \fBmkdir\fR(2) are suppressed\&. (fixme: delete the given subtree? like suggested by O_TRUNC? not done so far!)

.PP


.PP
If the third argument "ext" has another special meaning here, as it is used to ensure that a given zip\-file is created with the first entry of the ext\-list appended as an extension unless the file\-path already ends with a file\-extension registered in the list\&. Therefore {"",0} matches all files and creates them as zip\-archives under the given nonmodified name\&. (Some magic here? If the path ends in the path separator then make a real directory even in the presence of ext\-list?)

.PP
 \fBThe zzip_dir_creat_ext_io function\fR is not yet implemented, check for #def ZZIP_NO_CREAT Write\-support will extend \fBzzip_closedir\fR with semantics to finalize the zip\-archive by writing the zip\-trailer and closing the archive file\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

/115            1104300067  1001  0     100664  26        `
.so man3/zzip_dir_creat.3
zzip_dirfd.3/   1104300067  1001  0     100664  26        `
.so man3/zzip_dirhandle.3
/140            1104300067  1001  0     100664  1392      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DIR_FDOPEN" 3 "0.13.38" "zziplib" "zzip_dir_fdopen"
.SH NAME
zzip_dir_fdopen, zzip_dir_fdopen_ext_io \- (zzip/zip.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 29
ZZIP_DIR\ *\ \fBzzip_dir_fdopen\fR\ (int\ fd, zzip_error_t\ *\ errcode_p);
.HP 36
ZZIP_DIR\ *\ \fBzzip_dir_fdopen_ext_io\fR\ (int\ fd, zzip_error_t\ *\ errcode_p, zzip_strings_t*\ ext, const\ zzip_plugin_io_t\ io);
.ad
.hy

.SH "DESCRIPTION"

.PP
used by the \fBzzip_dir_open\fR and zzip_opendir(2) call\&. Opens the zip\-archive as specified with the fd which points to an already openend file\&. \fBThe zzip_dir_fdopen function\fR then search and parse the zip's central directory\&.

.PP
NOTE: refcount is zero, so an _open/_close pair will also delete this _dirhandle

.PP
 \fBthe zzip_dir_fdopen_ext_io function\fR uses explicit ext and io instead of the internal defaults, setting these to zero is equivalent to \fBzzip_dir_fdopen\fR 

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.LP

/159            1104300067  1001  0     100664  27        `
.so man3/zzip_dir_fdopen.3

zzip_dir_free.3/1104300067  1001  0     100664  1245      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DIR_FREE" 3 "0.13.38" "zziplib" "zzip_dir_free"
.SH NAME
zzip_dir_free, zzip_dir_close \- (zzip/zip.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 19
int\ \fBzzip_dir_free\fR\ (ZZIP_DIR\ *\ dir);
.HP 20
int\ \fBzzip_dir_close\fR\ (ZZIP_DIR\ *\ dir);
.ad
.hy

.SH "DESCRIPTION"

.PP
will free the zzip_dir handle unless there are still zzip_files attached (that may use its cache buffer)\&. This is the inverse of \fBzzip_dir_alloc\fR , and both are helper functions used implicitly in other zzipcalls e\&.g\&. \fBzzip_dir_close\fR = zzip_close

.PP
returns zero on sucess returns the refcount when files are attached\&.

.PP
It will also \fBfree\fR(2) the \fBZZIP_DIR\fR\-handle given\&. the counterpart for \fBzzip_dir_open\fR see also \fBzzip_dir_free\fR 

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.LP


/185            1104300067  1001  0     100664  1146      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DIRHANDLE" 3 "0.13.38" "zziplib" "zzip_dirhandle"
.SH NAME
zzip_dirhandle, zzip_dirfd \- (zzip/info.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 28
ZZIP_DIR\ *\ \fBzzip_dirhandle\fR\ (ZZIP_FILE\ *\ fp);
.HP 16
int\ \fBzzip_dirfd\fR\ (ZZIP_DIR*\ dir);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_dirhandle function\fR will just return fp\->dir

.PP
If a ZZIP_FILE is contained within a zip\-file that one will be a valid pointer, otherwise a NULL is returned and the ZZIP_FILE wraps a real file\&.

.PP
 \fBThe zzip_dirfd function\fR will just return dir\->fd

.PP
If a ZZIP_DIR does point to a zipfile then the file\-descriptor of that zipfile is returned, otherwise a NULL is returned and the ZZIP_DIR wraps a real directory DIR (if you have dirent on your system)\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

zzip_dir_open.3/1104300067  1001  0     100664  1533      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DIR_OPEN" 3 "0.13.38" "zziplib" "zzip_dir_open"
.SH NAME
zzip_dir_open, zzip_dir_open_ext_io, zzip_dir_read \- (zzip/zip.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 25
ZZIP_DIR*\ \fBzzip_dir_open\fR\ (zzip_char_t*\ filename, zzip_error_t*\ e);
.HP 32
ZZIP_DIR*\ \fBzzip_dir_open_ext_io\fR\ (zzip_char_t*\ filename, zzip_error_t*\ e, zzip_strings_t*\ ext, zzip_plugin_io_t\ io);
.HP 19
int\ \fBzzip_dir_read\fR\ (ZZIP_DIR\ *\ dir, ZZIP_DIRENT\ *\ d);
.ad
.hy

.SH "DESCRIPTION"

.PP
Opens the zip\-archive (if available)\&. the two ext_io arguments will default to use posix io and a set of default fileext that can atleast add \&.zip ext itself\&.

.PP
 \fBthe zzip_dir_open_ext_io function\fR uses explicit ext and io instead of the internal defaults\&. Setting these to zero is equivalent to \fBzzip_dir_open\fR 

.PP
fills the dirent\-argument with the values and increments the read\-pointer of the dir\-argument\&.

.PP
returns 0 if there no entry (anymore)\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.LP


/203            1104300067  1001  0     100664  25        `
.so man3/zzip_dir_open.3

zzip_dir_read.3/1104300067  1001  0     100664  25        `
.so man3/zzip_dir_open.3

zzip_dir_real.3/1104300067  1001  0     100664  26        `
.so man3/zzip_file_real.3
zzip_dir_stat.3/1104300067  1001  0     100664  1870      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DIR_STAT" 3 "0.13.38" "zziplib" "zzip_dir_stat"
.SH NAME
zzip_dir_stat, zzip_file_stat, zzip_fstat \- (zzip/stat.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 19
int\ \fBzzip_dir_stat\fR\ (ZZIP_DIR\ *\ dir, zzip_char_t*\ name, ZZIP_STAT\ *\ zs, int\ flags);
.HP 20
int\ \fBzzip_file_stat\fR\ (ZZIP_FILE*\ file, ZZIP_STAT*\ zs);
.HP 16
int\ \fBzzip_fstat\fR\ (ZZIP_FILE*\ file, ZZIP_STAT*\ zs);
.ad
.hy

.SH "DESCRIPTION"

.PP
obtain information about a filename in an opened zip\-archive without opening that file first\&. Mostly used to obtain the uncompressed size of a file inside a zip\-archive\&. see \fBzzip_dir_open\fR\&.

.PP
 \fBThe zzip_file_stat function\fR will obtain information about a opened file _within_ a zip\-archive\&. The file is supposed to be open (otherwise \-1 is returned)\&. The st_size stat\-member contains the uncompressed size\&. The optional d_name is never set here\&.

.PP
 \fBThe zzip_fstat function\fR will obtain information about a opened file which may be either real/zipped\&. The file is supposed to be open (otherwise \-1 is returned)\&. The st_size stat\-member contains the uncompressed size\&. The optional d_name is never set here\&. For a real file, we do set the d_csize := st_size and d_compr := 0 for meaningful defaults\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

/227            1104300067  1001  0     100664  26        `
.so man3/zzip_disk_mmap.3
/246            1104300067  1001  0     100664  27        `
.so man3/zzip_disk_fopen.3

/271            1104300067  1001  0     100664  35        `
.so man3/zzip_disk_entry_to_data.3

/302            1104300067  1001  0     100664  1909      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DISK_ENTRY_T" 3 "0.13.38" "zziplib" "zzip_disk_entry_to_data"
.SH NAME
zzip_disk_entry_to_data, zzip_disk_entry_to_file_header, zzip_disk_entry_strdup_name \- helper functions for (mmapped) zip access api
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/mmapped\&.h>

.sp
.HP 31
char*\ \fBzzip_disk_entry_to_data\fR\ (ZZIP_DISK*\ disk, struct\ zzip_disk_entry*\ entry);
.HP 58
struct\ zzip_file_header*\ \fBzzip_disk_entry_to_file_header\fR\ (ZZIP_DISK*\ disk, struct\ zzip_disk_entry*\ entry);
.HP 51
char*\ _zzip_restrict\ \fBzzip_disk_entry_strdup_name\fR\ (ZZIP_DISK*\ disk, struct\ zzip_disk_entry*\ entry);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_disk_entry_to_data function\fR augments the other zzip_disk_entry_* helpers: here we move a disk_entry pointer (as returned by _find* functions) into a pointer to the data block right after the file_header\&. Only disk\->buffer would be needed to perform the seek but we check the mmapped range end as well\&.

.PP
 \fBThe zzip_disk_entry_to_file_header function\fR does half the job of \fBzzip_disk_entry_to_data\fR where it can augment with \fBzzip_file_header_to_data\fR helper from format/fetch\&.h

.PP
 \fBThe zzip_disk_entry_strdup_name function\fR is a big helper despite its little name: in a zip file the encoded filenames are usually NOT zero\-terminated but for common usage with libc we need it that way\&. Secondly, the filename SHOULD be present in the zip central directory but if not then we fallback to the filename given in the file_header of each compressed data portion\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP


/329            1104300067  1001  0     100664  35        `
.so man3/zzip_disk_entry_to_data.3

/363            1104300067  1001  0     100664  27        `
.so man3/zzip_disk_fopen.3

/383            1104300067  1001  0     100664  27        `
.so man3/zzip_disk_fopen.3

/401            1104300067  1001  0     100664  4162      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DISK_FINDFILE" 3 "0.13.38" "zziplib" "zzip_disk_findfile"
.SH NAME
zzip_disk_findfile, zzip_disk_findfirst, zzip_disk_findnext, zzip_disk_findmatch \- search for files in the (mmapped) zip central directory
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/mmapped\&.h>

.sp
.HP 45
struct\ zzip_disk_entry*\ \fBzzip_disk_findfile\fR\ (ZZIP_DISK*\ disk, char*\ filename, struct\ zzip_disk_entry*\ after, zzip_strcmp_fn_t\ compare);
.HP 46
struct\ zzip_disk_entry*\ \fBzzip_disk_findfirst\fR\ (ZZIP_DISK*\ disk);
.HP 45
struct\ zzip_disk_entry*\ \fBzzip_disk_findnext\fR\ (ZZIP_DISK*\ disk, struct\ zzip_disk_entry*\ entry);
.HP 46
struct\ zzip_disk_entry*\ \fBzzip_disk_findmatch\fR\ (ZZIP_DISK*\ disk, char*\ filespec, struct\ zzip_disk_entry*\ after, zzip_fnmatch_fn_t\ compare, int\ flags);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_disk_findfile function\fR is given a filename as an additional argument, to find the disk_entry matching a given filename\&. The compare\-function is usually strcmp or strcasecmp or perhaps strcoll, if null then strcmp is used\&. \- use null as argument for "after"\-entry when searching the first matching entry, otherwise the last returned value if you look for other entries with a special "compare" function (if null then a doubled search is rather useless with this variant of _findfile)\&.

.PP


.PP
 \fBThe zzip_disk_findfirst function\fR is the first call of all the zip access functions here\&. It contains the code to find the first entry of the zip central directory\&. Here we require the mmapped block to represent a real zip file where the disk_trailer is _last_ in the file area, so that its position would be at a fixed offset from the end of the file area if not for the comment field allowed to be of variable length (which needs us to do a little search for the disk_tailer)\&. However, in this simple implementation we disregard any disk_trailer info telling about multidisk archives, so we just return a pointer to the zip central directory\&.

.PP
For an actual means, we are going to search backwards from the end of the mmaped block looking for the PK\-magic signature of a disk_trailer\&. If we see one then we check the rootseek value to find the first disk_entry of the root central directory\&. If we find the correct PK\-magic signature of a disk_entry over there then we assume we are done and we are going to return a pointer to that label\&.

.PP
The return value is a pointer to the first zzip_disk_entry being checked to be within the bounds of the file area specified by the arguments\&. If no disk_trailer was found then null is returned, and likewise we only accept a disk_trailer with a seekvalue that points to a disk_entry and both parts have valid PK\-magic parts\&. Beyond some sanity check we try to catch a common brokeness with zip archives that still allows us to find the start of the zip central directory\&.

.PP


.PP
 \fBThe zzip_disk_findnext function\fR takes an existing disk_entry in the central root directory (e\&.g\&. from zzip_disk_findfirst) and returns the next entry within in the given bounds of the mmapped file area\&.

.PP


.PP
 \fBThe zzip_disk_findmatch function\fR uses a compare\-function with an additional argument and it is called just like fnmatch(3) from POSIX\&.2 AD:1993), i\&.e\&. the argument filespec first and the ziplocal filename second with the integer\-flags put in as third to the indirect call\&. If the platform has fnmatch available then null\-compare will use that one and otherwise we fall back to mere strcmp, so if you need fnmatch searching then please provide an implementation somewhere else\&. \- use null as argument for "after"\-entry when searching the first matching entry, or the last disk_entry return\-value to find the next entry matching the given filespec\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

/423            1104300067  1001  0     100664  30        `
.so man3/zzip_disk_findfile.3
/446            1104300067  1001  0     100664  30        `
.so man3/zzip_disk_findfile.3
/469            1104300067  1001  0     100664  30        `
.so man3/zzip_disk_findfile.3
/491            1104300067  1001  0     100664  2563      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DISK_FOPEN" 3 "0.13.38" "zziplib" "zzip_disk_fopen"
.SH NAME
zzip_disk_fopen, zzip_disk_entry_fopen, zzip_disk_fread, zzip_disk_fclose, zzip_disk_feof \- openening a file part wrapped within a (mmapped) zip archive
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/mmapped\&.h>

.sp
.HP 49
ZZIP_DISK_FILE*\ _zzip_restrict\ \fBzzip_disk_fopen\fR\ (ZZIP_DISK*\ disk, char*\ filename);
.HP 55
ZZIP_DISK_FILE*\ _zzip_restrict\ \fBzzip_disk_entry_fopen\fR\ (ZZIP_DISK*\ disk, ZZIP_DISK_ENTRY*\ entry);
.HP 29
zzip_size_t\ \fBzzip_disk_fread\fR\ (void*\ ptr, zzip_size_t\ sized, zzip_size_t\ nmemb, ZZIP_DISK_FILE*\ file);
.HP 22
int\ \fBzzip_disk_fclose\fR\ (ZZIP_DISK_FILE*\ file);
.HP 20
int\ \fBzzip_disk_feof\fR\ (ZZIP_DISK_FILE*\ file);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_disk_fopen function\fR opens a file found by name, so it does a search into the zip central directory with \fBzzip_disk_findfile\fR and whatever is found first is given to \fBzzip_disk_entry_fopen\fR 

.PP


.PP
the ZZIP_DISK_FILE* is rather simple in just encapsulating the arguments given to \fBthe zzip_disk_entry_fopen function\fR plus a zlib deflate buffer\&. Note that the ZZIP_DISK pointer does already contain the full mmapped file area of a zip disk, so open()ing a file part within that area happens to be a lookup of its bounds and encoding\&. That information is memorized on the ZZIP_DISK_FILE so that subsequent _read() operations will be able to get the next data portion or return an eof condition for that file part wrapped in the zip archive\&.

.PP


.PP
 \fBThe zzip_disk_fread function\fR reads more bytes into the output buffer specified as arguments\&. The return value is null on eof or error, the stdio\-like interface can not distinguish between these so you need to check with \fBzzip_disk_feof\fR for the difference\&.

.PP
 \fBThe zzip_disk_fclose function\fR releases any zlib decoder info needed for decompression and dumps the ZZIP_DISK_FILE* then\&.

.PP


.PP
 \fBThe zzip_disk_feof function\fR allows to distinguish an error from an eof condition\&. Actually, if we found an error but we did already reach eof then we just keep on saying that it was an eof, so the app can just continue\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP


/510            1104300067  1001  0     100664  27        `
.so man3/zzip_disk_fopen.3

/529            1104300067  1001  0     100664  26        `
.so man3/zzip_disk_mmap.3
/547            1104300067  1001  0     100664  2350      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_DISK_MMAP" 3 "0.13.38" "zziplib" "zzip_disk_mmap"
.SH NAME
zzip_disk_mmap, zzip_disk_init, zzip_disk_new, zzip_disk_munmap, zzip_disk_open, zzip_disk_close \- turn a filehandle into a mmapped zip disk archive handle
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/mmapped\&.h>

.sp
.HP 43
ZZIP_DISK*\ _zzip_restrict\ \fBzzip_disk_mmap\fR\ (int\ fd);
.HP 20
int\ \fBzzip_disk_init\fR\ (ZZIP_DISK*\ disk, char*\ buffer, zzip_size_t\ buflen);
.HP 42
ZZIP_DISK*\ _zzip_restrict\ \fBzzip_disk_new\fR\ (void);
.HP 22
int\ \fBzzip_disk_munmap\fR\ (ZZIP_DISK*\ disk);
.HP 43
ZZIP_DISK*\ _zzip_restrict\ \fBzzip_disk_open\fR\ (char*\ filename);
.HP 21
int\ \fBzzip_disk_close\fR\ (ZZIP_DISK*\ disk);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_disk_mmap function\fR uses the given file\-descriptor to detect the length of the file and calls the system \fBmmap\fR(2) to put it in main memory\&. If it is successful then a newly allocated ZZIP_DISK* is returned with disk\->buffer pointing to the mapview of the zipdisk content\&.

.PP
 \fBThe zzip_disk_init function\fR does primary initialization of a disk\-buffer struct\&.

.PP
 \fBThe zzip_disk_new function\fR allocates a new disk\-buffer with \fBmalloc\fR(3)

.PP
 \fBThe zzip_disk_munmap function\fR is the inverse of \fBzzip_disk_mmap\fR and using the system munmap(2) on the buffer area and \fBfree\fR(3) on the ZZIP_DISK structure\&.

.PP


.PP
 \fBThe zzip_disk_open function\fR opens the given archive by name and turn the filehandle to \fBzzip_disk_mmap\fR for bringing it to main memory\&. If it can not be \fBmmap\fR(2)'ed then we slurp the whole file into a newly \fBmalloc\fR(2)'ed memory block\&. Only if that fails too then we return null\&. Since handling of disk\->buffer is ambigous it should not be snatched away please\&.

.PP


.PP
 \fBThe zzip_disk_close function\fR will release all data needed to access a (mmapped) zip archive, including any malloc()ed blocks, sharedmem mappings and it dumps the handle struct as well\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

/565            1104300067  1001  0     100664  26        `
.so man3/zzip_disk_mmap.3
zzip_disk_new.3/1104300067  1001  0     100664  26        `
.so man3/zzip_disk_mmap.3
/585            1104300067  1001  0     100664  26        `
.so man3/zzip_disk_mmap.3
/603            1104300067  1001  0     100664  2061      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_ENTRY_DATA_O" 3 "0.13.38" "zziplib" "zzip_entry_data_offset"
.SH NAME
zzip_entry_data_offset, zzip_entry_fread_file_header, zzip_entry_strdup_name \- helper functions for (fseeko) zip access api
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/fseeko\&.h>

.sp
.HP 35
zzip_off_t\ \fBzzip_entry_data_offset\fR\ (ZZIP_ENTRY*\ entry);
.HP 49
static\ zzip_off_t\ \fBzzip_entry_fread_file_header\fR\ (ZZIP_ENTRY*\ entry, struct\ zzip_file_header*\ file_header);
.HP 46
char*\ _zzip_restrict\ \fBzzip_entry_strdup_name\fR\ (ZZIP_ENTRY*\ entry);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_entry_data_offset function\fRs returns the seekval offset of the data portion of the file referenced by the given zzip_entry\&. It requires an intermediate check of the file_header structure (i\&.e\&. it reads it from disk)\&. After this call, the contained diskfile readposition is already set to the data_offset returned here\&. On error \-1 is returned\&.

.PP
 \fBThe zzip_entry_fread_file_header function\fRs read the correspoding struct zzip_file_header from the zip disk of the given "entry"\&. The returned off_t points to the end of the file_header where the current fseek pointer has stopped\&. This is used to immediatly parse out any filename/extras block following the file_header\&. The return value is null on error\&.

.PP
 \fBThe zzip_entry_strdup_name function\fR is a big helper despite its little name: in a zip file the encoded filenames are usually NOT zero\-terminated but for common usage with libc we need it that way\&. Secondly, the filename SHOULD be present in the zip central directory but if not then we fallback to the filename given in the file_header of each compressed data portion\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP


/629            1104300067  1001  0     100664  28        `
.so man3/zzip_entry_fopen.3
/650            1104300067  1001  0     100664  28        `
.so man3/zzip_entry_fopen.3
/669            1104300067  1001  0     100664  28        `
.so man3/zzip_entry_fopen.3
/689            1104300067  1001  0     100664  4950      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_ENTRY_FINDFILE" 3 "0.13.38" "zziplib" "zzip_entry_findfile"
.SH NAME
zzip_entry_findfile, zzip_entry_findfirst, zzip_entry_findnext, zzip_entry_free, zzip_entry_findmatch \- search for files in the (fseeko) zip central directory
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/fseeko\&.h>

.sp
.HP 49
ZZIP_ENTRY*\ _zzip_restrict\ \fBzzip_entry_findfile\fR\ (FILE*\ disk, char*\ filename, ZZIP_ENTRY*\ _zzip_restrict\ entry, zzip_strcmp_fn_t\ compare);
.HP 50
ZZIP_ENTRY*\ _zzip_restrict\ \fBzzip_entry_findfirst\fR\ (FILE*\ disk);
.HP 49
ZZIP_ENTRY*\ _zzip_restrict\ \fBzzip_entry_findnext\fR\ (ZZIP_ENTRY*\ _zzip_restrict\ entry);
.HP 21
int\ \fBzzip_entry_free\fR\ (ZZIP_ENTRY*\ entry);
.HP 50
ZZIP_ENTRY*\ _zzip_restrict\ \fBzzip_entry_findmatch\fR\ (FILE*\ disk, char*\ filespec, ZZIP_ENTRY*\ _zzip_restrict\ entry, zzip_fnmatch_fn_t\ compare, int\ flags);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_entry_findfile function\fR is given a filename as an additional argument, to find the disk_entry matching a given filename\&. The compare\-function is usually strcmp or strcasecmp or perhaps strcoll, if null then strcmp is used\&. \- use null as argument for "old"\-entry when searching the first matching entry, otherwise the last returned value if you look for other entries with a special "compare" function (if null then a doubled search is rather useless with this variant of _findfile)\&. If no further entry is found then null is returned and any "old"\-entry gets already free()d\&.

.PP


.PP
 \fBThe zzip_entry_findfirst function\fR is the first call of all the zip access functions here\&. It contains the code to find the first entry of the zip central directory\&. Here we require the stdio handle to represent a real zip file where the disk_trailer is _last_ in the file area, so that its position would be at a fixed offset from the end of the file area if not for the comment field allowed to be of variable length (which needs us to do a little search for the disk_tailer)\&. However, in this simple implementation we disregard any disk_trailer info telling about multidisk archives, so we just return a pointer to the first entry in the zip central directory of that file\&.

.PP
For an actual means, we are going to search backwards from the end of the mmaped block looking for the PK\-magic signature of a disk_trailer\&. If we see one then we check the rootseek value to find the first disk_entry of the root central directory\&. If we find the correct PK\-magic signature of a disk_entry over there then we assume we are done and we are going to return a pointer to that label\&.

.PP
The return value is a pointer to the first zzip_disk_entry being checked to be within the bounds of the file area specified by the arguments\&. If no disk_trailer was found then null is returned, and likewise we only accept a disk_trailer with a seekvalue that points to a disk_entry and both parts have valid PK\-magic parts\&. Beyond some sanity check we try to catch a common brokeness with zip archives that still allows us to find the start of the zip central directory\&.

.PP


.PP
 \fBThe zzip_entry_findnext function\fR takes an existing "entry" in the central root directory (e\&.g\&. from zzip_entry_findfirst) and moves it to point to the next entry\&. On error it returns 0, otherwise the old entry\&. If no further match is found then null is returned and the entry already free()d\&. If you want to stop searching for matches before that case then please call \fBzzip_entry_free\fR on the cursor struct ZZIP_ENTRY\&.

.PP
 \fBthe zzip_entry_free function\fR releases the malloc()ed areas needed for zzip_entry, the pointer is invalid afterwards\&. \fBThe zzip_entry_free function\fR has #define synonyms of zzip_entry_findlast(), zzip_entry_findlastfile(), zzip_entry_findlastmatch()

.PP


.PP
 \fBThe zzip_entry_findmatch function\fR uses a compare\-function with an additional argument and it is called just like fnmatch(3) from POSIX\&.2 AD:1993), i\&.e\&. the argument filespec first and the ziplocal filename second with the integer\-flags put in as third to the indirect call\&. If the platform has fnmatch available then null\-compare will use that one and otherwise we fall back to mere strcmp, so if you need fnmatch searching then please provide an implementation somewhere else\&. \- use null as argument for "after"\-entry when searching the first matching entry, or the last disk_entry return\-value to find the next entry matching the given filespec\&. If no further entry is found then null is returned and any "old"\-entry gets already free()d\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

/712            1104300067  1001  0     100664  31        `
.so man3/zzip_entry_findfile.3

/736            1104300067  1001  0     100664  31        `
.so man3/zzip_entry_findfile.3

/760            1104300067  1001  0     100664  31        `
.so man3/zzip_entry_findfile.3

/783            1104300067  1001  0     100664  2632      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_ENTRY_FOPEN" 3 "0.13.38" "zziplib" "zzip_entry_fopen"
.SH NAME
zzip_entry_fopen, zzip_entry_ffile, zzip_entry_fread, zzip_entry_fclose, zzip_entry_feof \- open a file within a zip disk for reading
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/fseeko\&.h>

.sp
.HP 51
ZZIP_ENTRY_FILE*\ _zzip_restrict\ \fBzzip_entry_fopen\fR\ (ZZIP_ENTRY*\ entry, int\ takeover);
.HP 51
ZZIP_ENTRY_FILE*\ _zzip_restrict\ \fBzzip_entry_ffile\fR\ (FILE*\ disk, char*\ filename);
.HP 30
zzip_size_t\ \fBzzip_entry_fread\fR\ (void*\ ptr, zzip_size_t\ sized, zzip_size_t\ nmemb, ZZIP_ENTRY_FILE*\ file);
.HP 23
int\ \fBzzip_entry_fclose\fR\ (ZZIP_ENTRY_FILE*\ file);
.HP 21
int\ \fBzzip_entry_feof\fR\ (ZZIP_ENTRY_FILE*\ file);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_entry_fopen function\fR does take an "entry" argument and copies it (or just takes it over as owner) to a new ZZIP_ENTRY_FILE handle structure\&. That structure contains also a zlib buffer for decoding\&. \fBThe zzip_entry_fopen function\fR does seek to the file_header of the given "entry" and validates it for the data buffer following it\&. We do also prefetch some data from the data buffer thereby trying to match the disk pagesize for faster access later\&. The \fBzzip_entry_fread\fR will then read in chunks of pagesizes which is the size of the internal readahead buffer\&. If an error occurs then null is returned\&.

.PP


.PP
 \fBThe zzip_entry_ffile function\fR opens a file found by name, so it does a search into the zip central directory with \fBzzip_entry_findfile\fR and whatever is found first is given to \fBzzip_entry_fopen\fR 

.PP


.PP
 \fBThe zzip_entry_fread function\fR reads more bytes into the output buffer specified as arguments\&. The return value is null on eof or error, the stdio\-like interface can not distinguish between these so you need to check with \fBzzip_entry_feof\fR for the difference\&.

.PP
 \fBThe zzip_entry_fclose function\fR releases any zlib decoder info needed for decompression and dumps the ZZIP_ENTRY_FILE struct then\&.

.PP


.PP
 \fBThe zzip_entry_feof function\fR allows to distinguish an error from an eof condition\&. Actually, if we found an error but we did already reach eof then we just keep on saying that it was an eof, so the app can just continue\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

/803            1104300067  1001  0     100664  28        `
.so man3/zzip_entry_fopen.3
/823            1104300067  1001  0     100664  34        `
.so man3/zzip_entry_data_offset.3
/855            1104300067  1001  0     100664  31        `
.so man3/zzip_entry_findfile.3

/874            1104300067  1001  0     100664  34        `
.so man3/zzip_entry_data_offset.3
zzip_errno.3/   1104300067  1001  0     100664  894       `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_ERRNO" 3 "0.13.38" "zziplib" "zzip_errno"
.SH NAME
zzip_errno \- (zzip/err.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 16
int\ \fBzzip_errno\fR\ (int\ errcode);
.ad
.hy

.SH "DESCRIPTION"

.PP
map the error code to a system error code\&. This is used for the drop\-in replacement functions to return a value that can be interpreted correctly by code sections that are unaware of the fact they their \fBopen\fR(2) call had been diverted to a file inside a zip\-archive\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

zzip_error.3/   1104300067  1001  0     100664  868       `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_ERROR" 3 "0.13.38" "zziplib" "zzip_error"
.SH NAME
zzip_error, zzip_seterror \- (zzip/info.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 16
int\ \fBzzip_error\fR\ (ZZIP_DIR\ *\ dir);
.HP 20
void\ \fBzzip_seterror\fR\ (ZZIP_DIR\ *\ dir, int\ errcode);
.ad
.hy

.SH "DESCRIPTION"

.PP
just returns dir\->errcode of the ZZIP_DIR handle see: \fBzzip_dir_open\fR, \fBzzip_diropen\fR, \fBzzip_readdir\fR, \fBzzip_dir_read\fR 

.PP
 \fBThe zzip_seterror function\fR just does dir\->errcode = errcode

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

zzip_fclose.3/  1104300067  1001  0     100664  989       `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_FCLOSE" 3 "0.13.38" "zziplib" "zzip_fclose"
.SH NAME
zzip_fclose, zzip_close \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 17
int\ \fBzzip_fclose\fR\ (ZZIP_FILE\ *\ fp);
.HP 16
int\ \fBzzip_close\fR\ (ZZIP_FILE*\ fp);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_fclose function\fR closes the given ZZIP_FILE handle\&.

.PP
If the ZZIP_FILE wraps a normal stat'fd then it is just that int'fd that is being closed and the otherwise empty ZZIP_FILE gets freed\&.

.PP


.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP


/900            1104300067  1001  0     100664  950       `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_FILE_CLOSE" 3 "0.13.38" "zziplib" "zzip_file_close"
.SH NAME
zzip_file_close \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 21
int\ \fBzzip_file_close\fR\ (ZZIP_FILE\ *\ fp);
.ad
.hy

.SH "DESCRIPTION"

.PP
the direct function of \fBzzip_close\fR(fp)\&. it will cleanup the inflate\-portion of \fBzlib\fR and free the structure given\&.

.PP
it is called quite from the error\-cleanup parts of the various \fB_open\fR functions\&.

.PP
the \&.refcount is decreased and if zero the fp\->dir is closed just as well\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

/919            1104300067  1001  0     100664  2934      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_FILE_CREAT" 3 "0.13.38" "zziplib" "zzip_file_creat"
.SH NAME
zzip_file_creat, zzip_file_mkdir \- start next file entry in a zip archive
.SH "SYNOPSIS"
.ad l
.hy 0


 #include <zziplib\&.h>

.sp
.HP 28
ZZIP_FILE*\ \fBzzip_file_creat\fR\ (ZZIP_DIR*\ dir, zzip_char_t*\ name, int\ o_mode);
.HP 21
int\ \fBzzip_file_mkdir\fR\ (ZZIP_DIR*\ dir, zzip_char_t*\ name, int\ o_mode);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_file_creat function\fR will create a new file within a zzip archive, the one given as the primary argument and additionally to the posix creat(2) \- just like zzip_mkdir has an additional argument over the posix mkdir(2) spec\&. For \fBthe zzip_file_creat function\fR the primary parameter can be null as well thereby creating a real file instead of a new one inside the zip\-archive otherwise given\&. If the primary parameter is not null but wraps a real directory then all new files are also real\&.

.PP
 \fBThe zzip_file_creat function\fR is not yet implemented, check for #def ZZIP_NO_CREAT

.PP
Returns NULL on an error setting errno, and opening a file _within_ a zip archive using O_RDONLY (and similar stuff) will surely lead to an error\&.

.PP


.PP
 \fBThe zzip_file_mkdir function\fR has an additional primary argument over the posix mkdir(2) \- if it is null then \fBthe zzip_file_mkdir function\fR behaves just like posix mkdir(2)\&. The zzip_dir argument can be set to the result of a \fBzzip_createdir\fR which allows for some magic that the given directory name is created as an entry in the zip archive\&.

.PP
If the given dir name argument is not within the basepath of the zip central directory then a real directory is created\&. Any EEXIST errors are not suppressed unlike with \fBzzip_createdir\fR 

.PP
Standard usage accepts a global/threaded/modular ZZIP_DIR pointer for all zip archive operations like in: 

.IP
  ZZIP_DIR* zip = zzip_createdir (sysconfpath, 0755, zip);  
   zzip_file_mkdir (zip, filepath[i], 0755);  
   ZZIP_FILE* file = zzip_file_creat (zip, filename[i], 0644);  
   zzip_write (file, buf, len);  
   zzip_close (file); file = 0;  
   zzip_closedir (zip); zip = 0; 

.PP
compare with \fBzzip_mkdir\fR inline macro which allows to collapse the examples script to 

.IP
  #define zzip_savefile myproject_saveconfig  
   #include <zzip/zzip\&.h>  
   ZZIP_DIR* zzip_savefile = zzip_createdir (sysconfpath, 0755);  
   zzip_mkdir (filepath[i], 0755);  
   ZZIP_FILE* file = zzip_creat(filepath[i], 0644);  
   zzip_write (file, buf, len);  
   zzip_close (file); file = 0;  
   zzip_closedir (zip_savefile); 

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

/938            1104300067  1001  0     100664  27        `
.so man3/zzip_file_creat.3

/957            1104300067  1001  0     100664  1004      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_FILE_OPEN" 3 "0.13.38" "zziplib" "zzip_file_open"
.SH NAME
zzip_file_open \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 29
ZZIP_FILE\ *\ \fBzzip_file_open\fR\ (ZZIP_DIR\ *\ dir, zzip_char_t*\ name, int\ o_mode);
.ad
.hy

.SH "DESCRIPTION"

.PP
open an \fBZZIP_FILE\fR from an already open \fBZZIP_DIR\fR handle\&. Since we have a chance to reuse a cached \fBbuf32k\fR and \fBZZIP_FILE\fR memchunk this is the best choice to unpack multiple files\&.

.PP
Note: the zlib supports 2\&.\&.15 bit windowsize, hence we provide a 32k memchunk here\&.\&.\&. just to be safe\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

/975            1104300067  1001  0     100664  1298      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_FILE_READ" 3 "0.13.38" "zziplib" "zzip_file_read"
.SH NAME
zzip_file_read \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 29
zzip_ssize_t\ \fBzzip_file_read\fR\ (ZZIP_FILE\ *\ fp, char\ *\ buf, zzip_size_t\ len);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_file_read function\fRs read data from zip\-contained file\&.

.PP
It works like \fBread\fR(2) and will fill the given buffer with bytes from the opened file\&. It will return the number of bytes read, so if the \fBEOF\fR is encountered you will be prompted with the number of bytes actually read\&.

.PP
This is the routines that needs the \fBbuf32k\fR buffer, and it would have need for much more polishing but it does already work quite well\&.

.PP
Note: the 32K buffer is rather big\&. The original inflate\-algorithm required just that but the latest zlib would work just fine with a smaller buffer\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

/993            1104300067  1001  0     100664  1521      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_FILE_REAL" 3 "0.13.38" "zziplib" "zzip_file_real"
.SH NAME
zzip_file_real, zzip_dir_real, zzip_realdir, zzip_realfd \- (zzip/info.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 20
int\ \fBzzip_file_real\fR\ (ZZIP_FILE*\ fp);
.HP 19
int\ \fBzzip_dir_real\fR\ (ZZIP_DIR*\ dir);
.HP 20
void*\ \fBzzip_realdir\fR\ (ZZIP_DIR*\ dir);
.HP 17
int\ \fBzzip_realfd\fR\ (ZZIP_FILE*\ fp);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_file_real function\fR checks if the ZZIP_FILE\-handle is wrapping a real file or a zip\-contained file\&. Returns 1 for a stat'able file, and 0 for a file inside a zip\-archive\&.

.PP
 \fBThe zzip_dir_real function\fR checks if the ZZIP_DIR\-handle is wrapping a real directory or a zip\-archive\&. Returns 1 for a stat'able directory, and 0 for a handle to zip\-archive\&.

.PP
 \fBThe zzip_realdir function\fR returns the posix DIR* handle (if one exists)\&. Check before with \fBzzip_dir_real\fR if the the ZZIP_DIR points to a real directory\&.

.PP
 \fBThe zzip_realfd function\fR returns the posix file descriptor (if one exists)\&. Check before with \fBzzip_file_real\fR if the the ZZIP_FILE points to a real file\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP


/1011           1104300067  1001  0     100664  25        `
.so man3/zzip_dir_stat.3

/1029           1104300067  1001  0     100664  22        `
.so man3/zzip_write.3
/1048           1104300067  1001  0     100664  917       `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "__ZZIP_FIND_DISK" 3 "0.13.38" "zziplib" "__zzip_find_disk_trailer"
.SH NAME
__zzip_find_disk_trailer \- (zzip/zip.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 30
int\ \fB__zzip_find_disk_trailer\fR\ (int\ fd, zzip_off_t\ filesize, struct\ zzip_disk_trailer\ *\ trailer, zzip_plugin_io_t\ io);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe __zzip_find_disk_trailer function\fR is used by \fBzzip_file_open\fR\&. It tries to find the zip's central directory info that is usually a few bytes off the end of the file\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.LP


zzip_fopen.3/   1104300067  1001  0     100664  4106      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_FOPEN" 3 "0.13.38" "zziplib" "zzip_fopen"
.SH NAME
zzip_fopen, zzip_freopen \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 23
ZZIP_FILE*\ \fBzzip_fopen\fR\ (zzip_char_t*\ filename, zzip_char_t*\ mode);
.HP 25
ZZIP_FILE*\ \fBzzip_freopen\fR\ (zzip_char_t*\ filename, zzip_char_t*\ mode, ZZIP_FILE*\ stream);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_fopen function\fR will \fBfopen\fR(3) a real/zipped file\&.

.PP
It has some magic functionality builtin \- it will first try to open the given filename as a normal file\&. If it does not exist, the given path to the filename (if any) is split into its directory\-part and the file\-part\&. A "\&.zip" extension is then added to the directory\-part to create the name of a zip\-archive\&. That zip\-archive (if it exists) is being searched for the file\-part, and if found a zzip\-handle is returned\&.

.PP
Note that if the file is found in the normal fs\-directory the returned structure is mostly empty and the \fBzzip_read\fR call will use the libc \fBread\fR to obtain data\&. Otherwise a \fBzzip_file_open\fR is performed and any error mapped to \fBerrno\fR(3)\&.

.PP
unlike the posix\-wrapper \fBzzip_open\fR the mode\-argument is a string which allows for more freedom to support the extra zzip modes called ZZIP_CASEINSENSITIVE and ZZIP_IGNOREPATH\&. Currently, this \fBzzip_fopen\fR call will convert the following characters in the mode\-string into their corrsponding mode\-bits:

.nf

\fB "r" : O_RDONLY : \fR read\-only
   \fB "b" : O_BINARY : \fR binary (win32 specific)
   \fB "f" : O_NOCTTY : \fR no char device (unix)
   \fB "i" : ZZIP_CASELESS : \fR inside zip file
   \fB "*" : ZZIP_NOPATHS : \fR inside zip file only
   
.fi

.PP
all other modes will be ignored for zip\-contained entries but they are transferred for compatibility and portability, including these extra sugar bits:

.nf

\fB "x" : O_EXCL :\fR fail if file did exist
   \fB "s" : O_SYNC :\fR synchronized access
   \fB "n" : O_NONBLOCK :\fR nonblocking access
   \fB "z#" : compression level :\fR for zlib
   \fB "g#" : group access :\fR unix access bits
   \fB "u#" : owner access :\fR unix access bits
   \fB "o#" : world access :\fR unix access bits
   
.fi

.PP
\&.\&.\&. the access bits are in traditional unix bit format with 7 = read/write/execute, 6 = read/write, 4 = read\-only\&.

.PP
The default access mode is 0664, and the compression level is ignored since the lib can not yet write zip files, otherwise it would be the initialisation value for the zlib deflateInit where 0 = no\-compression, 1 = best\-speed, 9 = best\-compression\&.

.PP


.PP
 \fBThe zzip_freopen function\fR receives an additional argument pointing to a ZZIP_FILE* being already in use\&. If this extra argument is null then \fBthe zzip_freopen function\fR is identical with calling \fBzzip_fopen\fR 

.PP
Per default, the old file stream is closed and only the internal structures associated with it are kept\&. These internal structures may be reused for the return value, and this is a lot quicker when the filename matches a zipped file that is incidently in the very same zip arch as the old filename wrapped in the stream struct\&.

.PP
That's simply because the zip arch's central directory does not need to be read again\&. As an extension for \fBthe zzip_freopen function\fR, if the mode\-string contains a "q" then the old stream is not closed but left untouched, instead it is only given as a hint that a new file handle may share/copy the zip arch structures of the old file handle if that is possible, i\&.e when they are in the same zip arch\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

zzip_fread.3/   1104300067  1001  0     100664  21        `
.so man3/zzip_read.3

zzip_freopen.3/ 1104300067  1001  0     100664  22        `
.so man3/zzip_fopen.3
zzip_fstat.3/   1104300067  1001  0     100664  25        `
.so man3/zzip_dir_stat.3

zzip_fwrite.3/  1104300067  1001  0     100664  22        `
.so man3/zzip_write.3
__zzip_get16.3/ 1104300067  1001  0     100664  24        `
.so man3/__zzip_get32.3
__zzip_get32.3/ 1104300067  1001  0     100664  1157      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "__ZZIP_GET32" 3 "0.13.38" "zziplib" "__zzip_get32"
.SH NAME
__zzip_get32, __zzip_get16, __zzip_set32, __zzip_set16 \- (zzip/fetch.c)
.SH "SYNOPSIS"
.ad l
.hy 0


 #include <zziplib\&.h>

.sp
.HP 23
uint32_t\ \fB__zzip_get32\fR\ (unsigned\ char\ *\ s);
.HP 23
uint16_t\ \fB__zzip_get16\fR\ (unsigned\ char\ *\ s);
.HP 19
void\ \fB__zzip_set32\fR\ (unsigned\ char\ *\ s, uint32_t\ v);
.HP 19
void\ \fB__zzip_set16\fR\ (unsigned\ char\ *\ s, uint16_t\ v);
.ad
.hy

.SH "DESCRIPTION"

.PP
Make 32 bit value in host byteorder from little\-endian mapped octet\-data (works also on machines which SIGBUS on misaligned data access (eg\&. 68000))

.PP
 \fBThe __zzip_get16 function\fR does the same for a 16 bit value\&.

.PP
 \fBThe __zzip_set32 function\fR pushes a 32bit value at the specified address

.PP
 \fBThe __zzip_set16 function\fR does the same for a 16 bit value\&.


/1076           1104300067  1001  0     100664  24        `
.so man3/zzip_init_io.3
/1099           1104300067  1001  0     100664  785       `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_INFLATE_INIT" 3 "0.13.38" "zziplib" "zzip_inflate_init"
.SH NAME
zzip_inflate_init \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 31
static\ int\ \fBzzip_inflate_init\fR\ (ZZIP_FILE\ *\ fp, struct\ zzip_dir_hdr*\ hdr);
.ad
.hy

.SH "DESCRIPTION"

.PP
call \fBinflateInit\fR and setup fp's iterator variables, used by lowlevel \fB_open\fR functions\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP


zzip_init_io.3/ 1104300067  1001  0     100664  1138      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_INIT_IO" 3 "0.13.38" "zziplib" "zzip_init_io"
.SH NAME
zzip_init_io, zzip_get_default_io \- (zzip/plugin.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 18
int\ \fBzzip_init_io\fR\ (zzip_plugin_io_handlers_t\ io, int\ flags);
.HP 38
zzip_plugin_io_t\ \fBzzip_get_default_io\fR\ ();
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_init_io function\fR initializes the users handler struct to default values being the posix io functions in default configured environments\&.

.PP
 \fBThe zzip_get_default_io function\fR returns a zzip_plugin_io_t handle to static defaults wrapping the posix io file functions for actual file access\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Mike Nordell <tamlin\-@\-algonet\-se>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Mike Nordell <tamlin\-@\-algonet\-se>
.LP

zziplib.h.3/    1104300067  1001  0     100664  4174      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIPLIB.H" 3 "0.13.38" "the library zziplib" ""
.SH NAME
zziplib.h \- library
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 21
void\ \fBzzip_rewinddir\fR\ (ZZIP_DIR\ *\ dir);
.HP 27
ZZIP_DIRENT*\ \fBzzip_readdir\fR\ (ZZIP_DIR\ *\ dir);
.HP 24
ZZIP_DIR*\ \fBzzip_opendir\fR\ (zzip_char_t*\ filename);
.HP 19
int\ \fBzzip_closedir\fR\ (ZZIP_DIR*\ dir);
.HP 28
zzip_char_t*\ \fBzzip_strerror\fR\ (int\ errcode);
.HP 16
int\ \fBzzip_errno\fR\ (int\ errcode);
.HP 23
uint32_t\ \fB__zzip_get32\fR\ (unsigned\ char\ *\ s);
.HP 21
int\ \fBzzip_file_close\fR\ (ZZIP_FILE\ *\ fp);
.HP 29
ZZIP_FILE\ *\ \fBzzip_file_open\fR\ (ZZIP_DIR\ *\ dir, zzip_char_t*\ name, int\ o_mode);
.HP 31
static\ int\ \fBzzip_inflate_init\fR\ (ZZIP_FILE\ *\ fp, struct\ zzip_dir_hdr*\ hdr);
.HP 17
int\ \fBzzip_fclose\fR\ (ZZIP_FILE\ *\ fp);
.HP 29
zzip_ssize_t\ \fBzzip_file_read\fR\ (ZZIP_FILE\ *\ fp, char\ *\ buf, zzip_size_t\ len);
.HP 24
zzip_ssize_t\ \fBzzip_read\fR\ (ZZIP_FILE\ *\ fp, char\ *\ buf, zzip_size_t\ len);
.HP 23
ZZIP_FILE*\ \fBzzip_fopen\fR\ (zzip_char_t*\ filename, zzip_char_t*\ mode);
.HP 22
ZZIP_FILE*\ \fBzzip_open\fR\ (zzip_char_t*\ filename, int\ o_flags);
.HP 17
int\ \fBzzip_rewind\fR\ (ZZIP_FILE\ *fp);
.HP 22
zzip_off_t\ \fBzzip_seek\fR\ (ZZIP_FILE\ *\ fp, zzip_off_t\ offset, int\ whence);
.HP 22
zzip_off_t\ \fBzzip_tell\fR\ (ZZIP_FILE\ *\ fp);
.HP 35
zzip_off_t\ \fBzzip_entry_data_offset\fR\ (ZZIP_ENTRY*\ entry);
.HP 49
ZZIP_ENTRY*\ _zzip_restrict\ \fBzzip_entry_findfile\fR\ (FILE*\ disk, char*\ filename, ZZIP_ENTRY*\ _zzip_restrict\ entry, zzip_strcmp_fn_t\ compare);
.HP 51
ZZIP_ENTRY_FILE*\ _zzip_restrict\ \fBzzip_entry_fopen\fR\ (ZZIP_ENTRY*\ entry, int\ takeover);
.HP 16
int\ \fBzzip_error\fR\ (ZZIP_DIR\ *\ dir);
.HP 28
ZZIP_DIR\ *\ \fBzzip_dirhandle\fR\ (ZZIP_FILE\ *\ fp);
.HP 29
zzip_char_t*\ \fBzzip_compr_str\fR\ (int\ compr);
.HP 20
int\ \fBzzip_file_real\fR\ (ZZIP_FILE*\ fp);
.HP 43
ZZIP_DISK*\ _zzip_restrict\ \fBzzip_disk_mmap\fR\ (int\ fd);
.HP 31
char*\ \fBzzip_disk_entry_to_data\fR\ (ZZIP_DISK*\ disk, struct\ zzip_disk_entry*\ entry);
.HP 45
struct\ zzip_disk_entry*\ \fBzzip_disk_findfile\fR\ (ZZIP_DISK*\ disk, char*\ filename, struct\ zzip_disk_entry*\ after, zzip_strcmp_fn_t\ compare);
.HP 49
ZZIP_DISK_FILE*\ _zzip_restrict\ \fBzzip_disk_fopen\fR\ (ZZIP_DISK*\ disk, char*\ filename);
.HP 18
int\ \fBzzip_init_io\fR\ (zzip_plugin_io_handlers_t\ io, int\ flags);
.HP 19
int\ \fBzzip_dir_stat\fR\ (ZZIP_DIR\ *\ dir, zzip_char_t*\ name, ZZIP_STAT\ *\ zs, int\ flags);
.HP 26
ZZIP_DIR*\ \fBzzip_dir_creat\fR\ (zzip_char_t*\ name, int\ o_mode);
.HP 26
ZZIP_DIR*\ \fBzzip_createdir\fR\ (zzip_char_t*\ name, int\ o_mode);
.HP 28
ZZIP_FILE*\ \fBzzip_file_creat\fR\ (ZZIP_DIR*\ dir, zzip_char_t*\ name, int\ o_mode);
.HP 25
zzip_ssize_t\ \fBzzip_write\fR\ (ZZIP_FILE*\ file, const\ void*\ ptr, zzip_size_t\ len);
.HP 24
int\ inline\ \fBzzip_mkdir\fR\ (zzip_char_t*\ name, int\ o_mode);
.HP 26
void\ inline\ \fBzzip_mkfifo\fR\ (zzip_char_t*\ name, int\ o_mode);
.HP 30
int\ \fB__zzip_find_disk_trailer\fR\ (int\ fd, zzip_off_t\ filesize, struct\ zzip_disk_trailer\ *\ trailer, zzip_plugin_io_t\ io);
.HP 33
int\ \fB__zzip_parse_root_directory\fR\ (int\ fd, struct\ zzip_disk_trailer\ *\ trailer, struct\ zzip_dir_hdr\ **\ hdr_return, zzip_plugin_io_t\ io);
.HP 33
ZZIP_DIR*\ \fBzzip_dir_alloc_ext_io\fR\ (zzip_strings_t*\ ext, const\ zzip_plugin_io_t\ io);
.HP 19
int\ \fBzzip_dir_free\fR\ (ZZIP_DIR\ *\ dir);
.HP 29
ZZIP_DIR\ *\ \fBzzip_dir_fdopen\fR\ (int\ fd, zzip_error_t\ *\ errcode_p);
.HP 21
int\ \fB__zzip_try_open\fR\ (zzip_char_t*\ filename, int\ filemode, zzip_strings_t*\ ext, zzip_plugin_io_t\ io);
.HP 25
ZZIP_DIR*\ \fBzzip_dir_open\fR\ (zzip_char_t*\ filename, zzip_error_t*\ e);
.ad
.hy

.SH "DESCRIPTION"

.PP
zziplib library

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.LP

zzip_mkdir.3/   1104300067  1001  0     100664  2059      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_MKDIR" 3 "0.13.38" "zziplib" "zzip_mkdir"
.SH NAME
zzip_mkdir, zzip_creat \- create a zipped file/directory
.SH "SYNOPSIS"
.ad l
.hy 0


 #include <zziplib\&.h>

.sp
.HP 24
int\ inline\ \fBzzip_mkdir\fR\ (zzip_char_t*\ name, int\ o_mode);
.HP 31
ZZIP_FILE*\ inline\ \fBzzip_creat\fR\ (zzip_char_t*\ name, int\ o_mode);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_mkdir function\fR creates a directory entry in the default zip\-archive\&. If you did not specify a "#define zzip_savefile somevar" then the default zip\-archive is null and all directories are created as real directories in the filesystem\&. \fBThe zzip_mkdir function\fR is really a preprocessor macro or preferably an inline function around \fBzzip_file_mkdir\fR, there is no such symbol generated into the library\&. The prototype is modelled after the posix \fBmkdir\fR(2) call\&. 

.IP
  #ifndef zzip_savefile  
   #define zzip_savefile 0  
   #endif  
   #define zzip_mkdir(name,mode) \\ \- zzip_file_mkdir(zzip_savefile,name,mode)

.PP


.PP


.PP
 \fBThe zzip_creat function\fR creates a file in the default zip\-archive\&. If you did not specify a "#define zzip_savefile somevar" then the default zip\-archive is null and all files are created as real files\&. \fBThe zzip_creat function\fR is really a preprocessor macro or preferably an inline function around \fBzzip_file_creat\fR, there is no such symbol generated into the library\&. The prototype is modelled after the posix \fBcreat\fR(2) call\&. 

.IP
  #ifndef zzip_savefile  
   #define zzip_savefile 0  
   #endif  
   #define zzip_creat(name,mode) \\ \- zzip_file_creat(zzip_savefile,name,mode)

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

.SH "SEE ALSO"

.PP
zzip_dir_creat, mkdir(2), creat(2), zzip_start


zzip_mkfifo.3/  1104300067  1001  0     100664  2483      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_MKFIFO" 3 "0.13.38" "zziplib" "zzip_mkfifo"
.SH NAME
zzip_mkfifo, zzip_sync \- start writing to the magic zzip_savefile
.SH "SYNOPSIS"
.ad l
.hy 0


 #include <zziplib\&.h>

.sp
.HP 26
void\ inline\ \fBzzip_mkfifo\fR\ (zzip_char_t*\ name, int\ o_mode);
.HP 24
void\ inline\ \fBzzip_sync\fR\ (void);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
open a zip archive for writing via the magic zzip_savefile macro variable\&. The name and mode are given to \fBzzip_createdir\fR and the result is stored into \fBzzip_savefile\fR \- if the \fBzzip_savefile\fR did already have a zzip_dir handle then it is automatically finalized with \fBzzip_sync\fR and the handle closed and the zzip_savefile variable reused for the new zip archive just started with this call\&. \- \fBThe zzip_mkfifo function\fR is really a preprocessor macro or preferably an inline function around \fBzzip_dir_create\fR, there is no such symbol generated into the library\&. 

.IP
  #ifndef zzip_savefile  
   #define zzip_savefile 0  
   #endif  
   #define zzip_start(name,mode,ext) \\ \- { if (zzip_savefile) zzip_closedir(zzip_savefile); \\ \- zzip_savefile = zzip_createdir(name,mode,ext); } \fBThe zzip_mkfifo function\fR returns null on error or a zzip_dir handle on success\&. It is perfectly okay to continue with a null in the zzip_savefile variable since it makes subsequent calls to \fBzzip_creat\fR and \fBzzip_mkdir\fR to run as \fBcreat\fR(2) / \fBmkdir\fR(2) on the real filesystem\&.

.PP


.PP
finalize a zip archive thereby writing the central directory to the end of the file\&. If it was a real directory then we do just nothing \- even that the prototype of the call itself is modelled to be similar to the posix \fBsync\fR(2) call\&. \fBThe zzip_sync function\fR is really a preprocessor macro or preferably an inline function around \fBzzip_closedir\fR, there is no such symbol generated into the library\&. 

.IP
  #ifndef zzip_savefile  
   #define zzip_savefile 0  
   #endif  
   #define zzip_sync(name,mode) \\ \- { zzip_closedir(zzip_savefile); zzip_savefile = 0; }

.PP


.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

.SH "SEE ALSO"

.PP
zzip_creat, zzip_write, zzip_closedir, sync(2)


zzip_open.3/    1104300067  1001  0     100664  3958      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_OPEN" 3 "0.13.38" "zziplib" "zzip_open"
.SH NAME
zzip_open, zzip_open_ext_io, zzip_open_shared_io \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 22
ZZIP_FILE*\ \fBzzip_open\fR\ (zzip_char_t*\ filename, int\ o_flags);
.HP 29
ZZIP_FILE*\ \fBzzip_open_ext_io\fR\ (zzip_char_t*\ filename, int\ o_flags, int\ o_modes, zzip_strings_t*\ ext, zzip_plugin_io_t\ io);
.HP 32
ZZIP_FILE*\ \fBzzip_open_shared_io\fR\ (ZZIP_FILE*\ stream, zzip_char_t*\ filename, int\ o_flags, int\ o_modes, zzip_strings_t*\ ext, zzip_plugin_io_t\ io);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_open function\fR will \fBopen\fR(2) a real/zipped file

.PP
It has some magic functionality builtin \- it will first try to open the given filename as a normal file\&. If it does not exist, the given path to the filename (if any) is split into its directory\-part and the file\-part\&. A "\&.zip" extension is then added to the directory\-part to create the name of a zip\-archive\&. That zip\-archive (if it exists) is being searched for the file\-part, and if found a zzip\-handle is returned\&.

.PP
Note that if the file is found in the normal fs\-directory the returned structure is mostly empty and the \fBzzip_read\fR call will use the libc \fBread\fR to obtain data\&. Otherwise a \fBzzip_file_open\fR is performed and any error mapped to \fBerrno\fR(3)\&.

.PP
There was a possibility to transfer zziplib\-specific openmodes through o_flags but you should please not use them anymore and look into \fBzzip_open_ext_io\fR to submit them down\&. \fBThe zzip_open function\fR is shallow in that it just extracts the zzipflags and calls

.nf

\fB
   zzip_open_ext_io(filename, o_flags, zzipflags|0664, 0, 0) \fR
.fi

.PP
you must stop using this extra functionality (not well known anyway) since zzip_open might be later usable to open files for writing in which case the _EXTRAFLAGS will get in conflict\&.

.PP
compare with \fBopen\fR(2) and \fBzzip_fopen\fR 

.PP


.PP
 \fBThe zzip_open_ext_io function\fR uses explicit ext and io instead of the internal defaults, setting them to zero is equivalent to \fBzzip_open\fR 

.PP
note that the two flag types have been split into an o_flags (for fcntl\-like openflags) and o_modes where the latter shall carry the zzip_flags and possibly accessmodes for unix filesystems\&. Since this version of zziplib can not write zipfiles, it is not yet used for anything else than zzip\-specific modeflags\&.

.PP


.PP
 \fBThe zzip_open_shared_io function\fR takes an extra stream argument \- if a handle has been then ext/io can be left null and the new stream handle will pick up the ext/io\&. This should be used only in specific environment however since \fBzzip_file_real\fR does not store any ext\-sequence\&.

.PP
The benefit for \fBthe zzip_open_shared_io function\fR comes in when the old file handle was openened from a file within a zip archive\&. When the new file is in the same zip archive then the internal zzip_dir structures will be shared\&. It is even quicker, as no check needs to be done anymore trying to guess the zip archive place in the filesystem, here we just check whether the zip archive's filepath is a prefix part of the filename to be opened\&.

.PP
Note that \fBthe zzip_open_shared_io function\fR is also used by \fBzzip_freopen\fR that will unshare the old handle, thereby possibly closing the handle\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

zzip_opendir.3/ 1104300067  1001  0     100664  1349      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_OPENDIR" 3 "0.13.38" "zziplib" "zzip_opendir"
.SH NAME
zzip_opendir, zzip_opendir_ext_io \- (zzip/dir.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 24
ZZIP_DIR*\ \fBzzip_opendir\fR\ (zzip_char_t*\ filename);
.HP 31
ZZIP_DIR*\ \fBzzip_opendir_ext_io\fR\ (zzip_char_t*\ filename, int\ o_modes, zzip_strings_t*\ ext, zzip_plugin_io_t\ io);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_opendir function\fR is the equivalent of \fBopendir\fR(3) for a realdir or zipfile\&.

.PP
 \fBThe zzip_opendir function\fR has some magic \- if the given argument\-path is a directory, it will wrap a real \fBopendir\fR(3) into the ZZIP_DIR structure\&. Otherwise it will divert to \fBzzip_dir_open\fR which can also attach a "\&.zip" extension if needed to find the archive\&.

.PP
the error\-code is mapped to \fBerrno\fR(3)\&.

.PP
 \fBThe zzip_opendir_ext_io function\fR uses explicit ext and io instead of the internal defaults, setting them to zero is equivalent to \fBzzip_opendir\fR 

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP


/1120           1104300067  1001  0     100664  24        `
.so man3/zzip_opendir.3
/1143           1104300067  1001  0     100664  21        `
.so man3/zzip_open.3

/1163           1104300067  1001  0     100664  21        `
.so man3/zzip_open.3

/1186           1104300067  1001  0     100664  1010      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "__ZZIP_PARSE_RO" 3 "0.13.38" "zziplib" "__zzip_parse_root_directory"
.SH NAME
__zzip_parse_root_directory \- (zzip/zip.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 33
int\ \fB__zzip_parse_root_directory\fR\ (int\ fd, struct\ zzip_disk_trailer\ *\ trailer, struct\ zzip_dir_hdr\ **\ hdr_return, zzip_plugin_io_t\ io);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe __zzip_parse_root_directory function\fR is used by \fBzzip_file_open\fR, it is usually called after \fB__zzip_find_disk_trailer\fR\&. It will parse the zip's central directory information and create a zziplib private directory table in memory\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.LP

zzip_read.3/    1104300067  1001  0     100664  1416      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_READ" 3 "0.13.38" "zziplib" "zzip_read"
.SH NAME
zzip_read, zzip_fread \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 24
zzip_ssize_t\ \fBzzip_read\fR\ (ZZIP_FILE\ *\ fp, char\ *\ buf, zzip_size_t\ len);
.HP 24
zzip_size_t\ \fBzzip_fread\fR\ (void\ *ptr, zzip_size_t\ size, zzip_size_t\ nmemb, ZZIP_FILE\ *file);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_read function\fR will read(2) data from a real/zipped file\&.

.PP
the replacement for \fBread\fR(2) will fill the given buffer with bytes from the opened file\&. It will return the number of bytes read, so if the EOF is encountered you will be prompted with the number of bytes actually read\&.

.PP
If the file\-handle is wrapping a stat'able file then it will actually just perform a normal \fBread\fR(2)\-call, otherwise \fBzzip_file_read\fR is called to decompress the data stream and any error is mapped to \fBerrno\fR(3)\&.

.PP


.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

zzip_readdir.3/ 1104300067  1001  0     100664  1033      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_READDIR" 3 "0.13.38" "zziplib" "zzip_readdir"
.SH NAME
zzip_readdir \- (zzip/dir.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 27
ZZIP_DIRENT*\ \fBzzip_readdir\fR\ (ZZIP_DIR\ *\ dir);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_readdir function\fR is the equivalent of a \fBreaddir\fR(2) for a realdir or a zipfile referenced by the ZZIP_DIR returned from \fBzzip_opendir\fR\&.

.PP
The ZZIP_DIR handle (as returned by \fBzzip_opendir\fR) contains a few more entries than being copied into the ZZIP_DIRENT\&. The only valid fields in a ZZIP_DIRENT are d_name (the file name), d_compr (compression), d_csize (compressed size), st_size (uncompressed size)\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP


zzip_realdir.3/ 1104300067  1001  0     100664  26        `
.so man3/zzip_file_real.3
zzip_realfd.3/  1104300067  1001  0     100664  26        `
.so man3/zzip_file_real.3
zzip_rewind.3/  1104300067  1001  0     100664  798       `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_REWIND" 3 "0.13.38" "zziplib" "zzip_rewind"
.SH NAME
zzip_rewind \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 17
int\ \fBzzip_rewind\fR\ (ZZIP_FILE\ *fp);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_rewind function\fR will rewind a real/zipped file\&.

.PP
It seeks to the beginning of this file's data in the zip, or the beginning of the file for a stat'fd\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

/1217           1104300067  1001  0     100664  1259      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_REWINDDIR" 3 "0.13.38" "zziplib" "zzip_rewinddir"
.SH NAME
zzip_rewinddir, zzip_telldir, zzip_seekdir \- (zzip/dir.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 21
void\ \fBzzip_rewinddir\fR\ (ZZIP_DIR\ *\ dir);
.HP 25
zzip_off_t\ \fBzzip_telldir\fR\ (ZZIP_DIR*\ dir);
.HP 19
void\ \fBzzip_seekdir\fR\ (ZZIP_DIR*\ dir, zzip_off_t\ offset);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_rewinddir function\fR is the equivalent of a \fBrewinddir\fR(2) for a realdir or the zipfile in place of a directory\&. The ZZIP_DIR handle returned from \fBzzip_opendir\fR has a flag saying realdir or zipfile\&. As for a zipfile, the filenames will include the filesubpath, so take care\&.

.PP
 \fBThe zzip_telldir function\fR is the equivalent of \fBtelldir\fR(2) for a realdir or zipfile\&.

.PP
 \fBThe zzip_seekdir function\fR is the equivalent of \fBseekdir\fR(2) for a realdir or zipfile\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP


zzip_seek.3/    1104300067  1001  0     100664  1338      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_SEEK" 3 "0.13.38" "zziplib" "zzip_seek"
.SH NAME
zzip_seek \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 22
zzip_off_t\ \fBzzip_seek\fR\ (ZZIP_FILE\ *\ fp, zzip_off_t\ offset, int\ whence);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_seek function\fR will perform a \fBlseek\fR(2) operation on a real/zipped file

.PP
It will try to seek to the offset specified by offset, relative to whence, which is one of SEEK_SET, SEEK_CUR or SEEK_END\&.

.PP
If the file\-handle is wrapping a stat'able file then it will actually just perform a normal \fBlseek\fR(2)\-call\&. Otherwise the relative offset is calculated, negative offsets are transformed into positive ones by rewinding the file, and then data is read until the offset is reached\&. This can make the function terribly slow, but this is how gzio implements it, so I'm not sure there is a better way without using the internals of the algorithm\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

zzip_seekdir.3/ 1104300067  1001  0     100664  26        `
.so man3/zzip_rewinddir.3
__zzip_set16.3/ 1104300067  1001  0     100664  24        `
.so man3/__zzip_get32.3
__zzip_set32.3/ 1104300067  1001  0     100664  24        `
.so man3/__zzip_get32.3
zzip_seterror.3/1104300067  1001  0     100664  22        `
.so man3/zzip_error.3
zzip_strerror.3/1104300067  1001  0     100664  1313      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_STRERROR" 3 "0.13.38" "zziplib" "zzip_strerror"
.SH NAME
zzip_strerror, zzip_strerror_of \- (zzip/err.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 28
zzip_char_t*\ \fBzzip_strerror\fR\ (int\ errcode);
.HP 31
zzip_char_t*\ \fBzzip_strerror_of\fR\ (ZZIP_DIR*\ dir);
.ad
.hy

.SH "DESCRIPTION"

.PP
returns the static string for the given error code\&. The error code can be either a normal system error (a positive error code will flag this), it can be \fBlibz\fR error code (a small negative error code will flag this) or it can be an error code from \fBlibzzip\fR, which is an negative value lower than \fBZZIP_ERROR\fR 

.PP
 \fBThe zzip_strerror_of function\fR fetches the errorcode from the \fBDIR\fR\-handle and runs it through \fBzzip_strerror\fR to obtain the static string describing the error\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.TP
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP


/1235           1104300067  1001  0     100664  25        `
.so man3/zzip_strerror.3

zzip_sync.3/    1104300067  1001  0     100664  23        `
.so man3/zzip_mkfifo.3

zzip_tell.3/    1104300067  1001  0     100664  1060      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_TELL" 3 "0.13.38" "zziplib" "zzip_tell"
.SH NAME
zzip_tell \- (zzip/file.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 22
zzip_off_t\ \fBzzip_tell\fR\ (ZZIP_FILE\ *\ fp);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBThe zzip_tell function\fR will \fBtell\fR(2) the current position in a real/zipped file

.PP
It will return the current offset within the real/zipped file, measured in uncompressed bytes for the zipped\-file case\&.

.PP
If the file\-handle is wrapping a stat'able file then it will actually just perform a normal \fBtell\fR(2)\-call, otherwise the offset is calculated from the amount of data left and the total uncompressed size;

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <Tomi\&.Ollila@iki\&.fi>
.LP

zzip_telldir.3/ 1104300067  1001  0     100664  26        `
.so man3/zzip_rewinddir.3
/1255           1104300067  1001  0     100664  866       `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "__ZZIP_TRY_OPEN" 3 "0.13.38" "zziplib" "__zzip_try_open"
.SH NAME
__zzip_try_open \- (zzip/zip.c)
.SH "SYNOPSIS"
.ad l
.hy 0




#include <zzip/lib\&.h>

.sp
.HP 21
int\ \fB__zzip_try_open\fR\ (zzip_char_t*\ filename, int\ filemode, zzip_strings_t*\ ext, zzip_plugin_io_t\ io);
.ad
.hy

.SH "DESCRIPTION"

.PP
will attach a \&.zip extension and tries to open it the with \fBopen\fR(2)\&. This is a helper function for \fBzzip_dir_open\fR, \fBzzip_opendir\fR and \fBzzip_open\fR\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.TP
\(bu
Tomi Ollila <too@iki\&.fi>
.LP

zzip_write.3/   1104300067  1001  0     100664  2263      `
.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "ZZIP_WRITE" 3 "0.13.38" "zziplib" "zzip_write"
.SH NAME
zzip_write, zzip_file_write, zzip_fwrite \- write to zzip storage
.SH "SYNOPSIS"
.ad l
.hy 0


 #include <zziplib\&.h>

.sp
.HP 25
zzip_ssize_t\ \fBzzip_write\fR\ (ZZIP_FILE*\ file, const\ void*\ ptr, zzip_size_t\ len);
.HP 30
zzip_ssize_t\ \fBzzip_file_write\fR\ (ZZIP_FILE*\ file, const\ void*\ ptr, zzip_size_t\ len);
.HP 25
zzip_size_t\ \fBzzip_fwrite\fR\ (const\ void*\ ptr, zzip_size_t\ len, zzip_size_t\ multiply, ZZIP_FILE*\ file);
.ad
.hy

.SH "DESCRIPTION"

.PP


.PP
 \fBThe zzip_write function\fR will write data to a file descriptor\&. If the file descriptor represents a real file then it will be forwarded to call posix \fBwrite\fR(2) directly\&. If it is a descriptor for a file within a zip directory then the data will be "deflated" using \fBzlib\fR(3) and appended to the zip archive file\&.

.PP


.PP
 \fBThe zzip_file_write function\fR will write data to a file descriptor inside a zip archive\&. The data will be "deflated" using \fBzlib\fR(3) compression and appended to the end of the zip archive file\&. Only one file descriptor may be open per zzip_dir archive handle (fifo\-like)\&.

.PP
 \fBThe zzip_file_write function\fR is not yet implemented, check for #def ZZIP_NO_CREAT It returns immediately \-1 and sets errno=EROFS for indication\&.

.PP
 \fBThe zzip_fwrite function\fR is the stdc variant for writing and the arguments are forwarded to \fBzzip_write\fR \- the return value is floored to null as for STDC spec but there is no zzip_ferror call so far for the zziplib (later? is it actually needed?)\&.

.PP
 \fBThe zzip_fwrite function\fR is not yet implemented, check for #def ZZIP_NO_CREAT Write\-support extends \fBzzip_close\fR with semantics to write out a file\-trailer to the zip\-archive leaving a name/offset marker in the (still\-open) ZZIP_DIR handle\&.

.SH "AUTHOR"

.TP 3
\(bu
Guido Draheim <guidod@gmx\&.de>
.LP

.SH "SEE ALSO"

.PP
write(2), zlib(3), zzip_file_creat


